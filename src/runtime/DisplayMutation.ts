import { SecureBuffer } from '../security/RootKeyService';
import { MemoryWiper }  from '../security/MemoryWiper';

/**
 * DisplayMutation — reversible in-memory transform driven by EphemeralKey.
 *
 * Purpose: The bytes stored in memory between FragmentEngine.decrypt() and
 * the final display call are not a valid JPEG/PNG. A memory dump at this
 * point produces unusable data. Only the renderer can produce a valid image
 * by calling reverseMutation() immediately before pixel output.
 *
 * Algorithm:
 *   mutated[i] = plaintext[i] XOR xorStream[i]
 *
 * where xorStream is generated by an xorshift32 PRNG seeded by EphemeralKey.
 * Since XOR is self-inverse, reverseMutation === applyMutation.
 *
 * The EphemeralKey changes every render call, so each "stored-in-memory"
 * representation of the same page looks different across reading sessions.
 */
export class DisplayMutation {

  static async applyMutation(data: Uint8Array, key: SecureBuffer): Promise<Uint8Array> {
    const keyBytes = key as unknown as Uint8Array;
    const stream   = this._xorStream(keyBytes, data.length);
    const out      = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) out[i] = data[i] ^ stream[i];
    MemoryWiper.wipeUint8Array(stream);
    return out;
  }

  /** Identical to applyMutation — XOR is self-inverse. */
  static async reverseMutation(mutated: Uint8Array, key: SecureBuffer): Promise<Uint8Array> {
    return this.applyMutation(mutated, key);
  }

  /**
   * Generate a deterministic XOR stream from the key.
   * Uses a keyed xorshift32 variant with periodic key re-injection.
   */
  private static _xorStream(key: Uint8Array, length: number): Uint8Array {
    const stream = new Uint8Array(length);
    // Seed from key bytes
    let s = 0;
    for (let i = 0; i < key.length; i++) {
      s = (((s << 5) >>> 0) ^ (s >>> 3) ^ key[i]) >>> 0;
    }
    // Expand
    for (let i = 0; i < length; i++) {
      // Re-inject key material every 64 bytes to maintain entropy
      if (i > 0 && (i & 63) === 0) {
        const ki = (i >>> 6) % key.length;
        s ^= (key[ki] | (key[(ki + 1) % key.length] << 8)) >>> 0;
      }
      // xorshift32
      s ^= s << 13;  s = s >>> 0;
      s ^= s >>> 17; s = s >>> 0;
      s ^= s << 5;   s = s >>> 0;
      stream[i] = s & 0xFF;
    }
    return stream;
  }
}
